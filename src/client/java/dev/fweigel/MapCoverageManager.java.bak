package dev.fweigel;

import net.minecraft.core.BlockPos;
import net.minecraft.world.level.saveddata.maps.MapItemSavedData;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MapCoverageManager {
    public static final int MAP_TILE_SIZE = 128;
    public static final int MAP_TILE_RADIUS = MAP_TILE_SIZE / 2;
    private static final Set<Long> mappedAreas = new HashSet<>();
    private static final Set<Long> forcedMappedAreas = new HashSet<>();
    private static final Map<Long, Integer> mapIds = new HashMap<>();
    private static BlockPos targetStart = null;
    private static BlockPos targetEnd = null;
    private static boolean overlayEnabled = false;
    private static boolean isLoadingState = false;
    private static long coverageVersion = 0;
    private static long targetVersion = 0;
    private static CoverageGrid cachedGrid = null;

    private MapCoverageManager() {
    }

    public static void setTarget(BlockPos start, BlockPos end) {
        targetStart = start;
        targetEnd = end;
        overlayEnabled = true;
        bumpTargetVersion();
        saveState();
    }

    public static void setTargetArea(int x1, int z1, int x2, int z2) {
        setTarget(new BlockPos(x1, 0, z1), new BlockPos(x2, 0, z2));
    }

    public void addCoveredRegion(int x, int z) {
        markMapped(x, z, null);
    }

    public static boolean hasTarget() {
        return targetStart != null && targetEnd != null;
    }

    public static boolean isOverlayEnabled() {
        return overlayEnabled && hasTarget();
    }

    public static void toggleOverlay() {
        overlayEnabled = !overlayEnabled && hasTarget();
        saveState();
    }

    public static void setOverlayEnabled(boolean enabled) {
        overlayEnabled = enabled && hasTarget();
        saveState();
    }

    public static BlockPos getTargetStart() {
        return targetStart;
    }

    public static BlockPos getTargetEnd() {
        return targetEnd;
    }

    public static void markMapped(int x, int z) {
        markMapped(x, z, null);
    }

    public static void markMapped(int x, int z, Integer mapId) {
        long key = getGridKey(x, z);
        boolean added = mappedAreas.add(key);
        boolean mapIdAdded = false;
        if (mapId != null) {
            mapIdAdded = mapIds.putIfAbsent(key, mapId) == null;
        }
        if (added || mapIdAdded) {
            bumpCoverageVersion();
        }
        saveState();
    }

    
    public static void toggleMapped(int x, int z) {
        long key = getGridKey(x, z);

        // If it was forced, unforce it too so "toggle" always flips green/red visually
        boolean wasForced = forcedMappedAreas.remove(key);

        boolean changed;
        if (mappedAreas.contains(key)) {
            mappedAreas.remove(key);
            mapIds.remove(key);
            changed = true;
        } else {
            mappedAreas.add(key);
            changed = true;
        }

        if (changed || wasForced) {
            bumpCoverageVersion();
            saveState();
        }
    }

public static boolean isMapped(int x, int z) {
        long key = getGridKey(x, z);
    return mappedAreas.contains(key) || forcedMappedAreas.contains(key);
    }

    public static Integer getMapId(int x, int z) {
        return mapIds.get(getGridKey(x, z));
    }
    public static boolean isForcedMapped(int x, int z) {
        return forcedMappedAreas.contains(getGridKey(x, z));
    }

    public static void toggleForcedMapped(int x, int z) {
        long key = getGridKey(x, z);

        if (forcedMappedAreas.contains(key)) {
            forcedMappedAreas.remove(key);
        } else {
            forcedMappedAreas.add(key);
        }

        bumpCoverageVersion();
        saveState();
    }

    public static void clearForcedMapped(int x, int z) {
        long key = getGridKey(x, z);
        if (forcedMappedAreas.remove(key)) {
            bumpCoverageVersion();
            saveState();
        }
    }



public static void clearForcedMapped() {
    if (!forcedMappedAreas.isEmpty()) {
        forcedMappedAreas.clear();
        bumpCoverageVersion();
        saveState();
    }
}

    public static int alignToMapCenter(int coordinate, byte scale) {
        int gridSize = MAP_TILE_SIZE << scale;
        int centerOffset = gridSize / 2 - MAP_TILE_RADIUS;

        return Math.floorDiv(coordinate + MAP_TILE_RADIUS, gridSize) * gridSize + centerOffset;
    }

    public static int toGridIndex(int coordinate, byte scale) {
        int gridSize = MAP_TILE_SIZE << scale;
        return Math.floorDiv(coordinate + MAP_TILE_RADIUS, gridSize);
    }

    public static int toGridIndex(int coordinate) {
        return toGridIndex(coordinate, (byte) 0);
    }

    public static int gridIndexToStart(int gridIndex, byte scale) {
        int gridSize = MAP_TILE_SIZE << scale;
        return gridIndex * gridSize - MAP_TILE_RADIUS;
    }

    public static int gridIndexToStart(int gridIndex) {
        return gridIndexToStart(gridIndex, (byte) 0);
    }

    public static Integer resolveMapCenter(int reportedCenter, Integer fallbackCoordinate, byte scale) {
        if (reportedCenter != 0) {
            return reportedCenter;
        }

        if (fallbackCoordinate == null) {
            return null;
        }

        return alignToMapCenter(fallbackCoordinate, scale);
    }

    public static void trackMapData(MapItemSavedData data, BlockPos fallbackCenter, Integer mapId) {
        if ((data == null && fallbackCenter == null) || (data != null && data.scale != 0)) {
            return;
        }

        byte scale = data != null ? data.scale : 0;
        Integer centerX = resolveMapCenter(data != null ? data.centerX : 0,
                fallbackCenter != null ? fallbackCenter.getX() : null, scale);
        Integer centerZ = resolveMapCenter(data != null ? data.centerZ : 0,
                fallbackCenter != null ? fallbackCenter.getZ() : null, scale);
        if (centerX != null && centerZ != null) {
            markMapped(centerX, centerZ, mapId);
        }
    }

    private static long getGridKey(int x, int z) {
        int gx = toGridIndex(x);
        int gz = toGridIndex(z);
        return getGridKeyFromGridIndex(gx, gz);
    }

    private static long getGridKeyFromGridIndex(int gx, int gz) {
        return (((long) gx) << 32) | (gz & 0xFFFFFFFFL);
    }

    public static void reset(boolean clearSavedData) {
        overlayEnabled = false;
        targetStart = null;
        targetEnd = null;
        mappedAreas.clear();
        forcedMappedAreas.clear();
        mapIds.clear();
        MapCreationTracker.reset();
        bumpCoverageVersion();
        bumpTargetVersion();

        if (clearSavedData) {
            MapCoverageStorage.clearSavedData();
        }
    }

    public static void reset() {
        reset(false);
    }

    public static void loadState(MapCoverageState state) {
        isLoadingState = true;
        reset(false);

        if (state != null) {
            targetStart = state.targetStartPos();
            targetEnd = state.targetEndPos();
            overlayEnabled = state.overlayEnabled() && hasTarget();
            mappedAreas.addAll(state.mappedAreasCopy());
            forcedMappedAreas.addAll(state.forcedMappedAreasCopy());
            mapIds.putAll(state.mapIdsCopy());
        }

        isLoadingState = false;
        bumpCoverageVersion();
        bumpTargetVersion();
    }

    public static MapCoverageState getStateSnapshot() {
        return MapCoverageState.snapshotFrom(targetStart, targetEnd, overlayEnabled,
        new HashSet<>(mappedAreas), new HashSet<>(forcedMappedAreas), new HashMap<>(mapIds));
    }

    private static void saveState() {
        if (!isLoadingState) {
            MapCoverageStorage.save(getStateSnapshot());
        }
    }

    private static void bumpCoverageVersion() {
        coverageVersion++;
        cachedGrid = null;
    }

    private static void bumpTargetVersion() {
        targetVersion++;
        cachedGrid = null;
    }

    public static CoverageGrid getCoverageGrid(BlockPos start, BlockPos end) {
        if (start == null || end == null) {
            return null;
        }

        int xMin = Math.min(start.getX(), end.getX());
        int xMax = Math.max(start.getX(), end.getX());
        int zMin = Math.min(start.getZ(), end.getZ());
        int zMax = Math.max(start.getZ(), end.getZ());

        int gxMin = toGridIndex(xMin);
        int gxMax = toGridIndex(xMax);
        int gzMin = toGridIndex(zMin);
        int gzMax = toGridIndex(zMax);

        int columns = gxMax - gxMin + 1;
        int rows = gzMax - gzMin + 1;
        if (columns <= 0 || rows <= 0) {
            return null;
        }

        if (cachedGrid != null
                && cachedGrid.matches(gxMin, gxMax, gzMin, gzMax, coverageVersion, targetVersion)) {
            return cachedGrid;
        }

        boolean[] mapped = new boolean[columns * rows];
        int[] mapIdLookup = new int[columns * rows];
        int mappedCount = 0;

        for (int gx = 0; gx < columns; gx++) {
            for (int gz = 0; gz < rows; gz++) {
                int worldGX = gxMin + gx;
                int worldGZ = gzMin + gz;
                long key = getGridKeyFromGridIndex(worldGX, worldGZ);
                boolean isMapped = mappedAreas.contains(key) || forcedMappedAreas.contains(key);
                int index = gz * columns + gx;
                mapped[index] = isMapped;
                Integer mapId = mapIds.get(key);
                mapIdLookup[index] = mapId != null ? mapId : -1;
                if (isMapped) {
                    mappedCount++;
                }
            }
        }

        cachedGrid = new CoverageGrid(gxMin, gxMax, gzMin, gzMax, columns, rows, mappedCount, mapped, mapIdLookup,
                coverageVersion, targetVersion);
        return cachedGrid;
    }

    public static final class CoverageGrid {
        private final int gxMin;
        private final int gxMax;
        private final int gzMin;
        private final int gzMax;
        private final int columns;
        private final int rows;
        private final int mappedCount;
        private final boolean[] mapped;
        private final int[] mapIdLookup;
        private final long coverageVersion;
        private final long targetVersion;

        private CoverageGrid(int gxMin, int gxMax, int gzMin, int gzMax, int columns, int rows, int mappedCount,
                             boolean[] mapped, int[] mapIdLookup, long coverageVersion, long targetVersion) {
            this.gxMin = gxMin;
            this.gxMax = gxMax;
            this.gzMin = gzMin;
            this.gzMax = gzMax;
            this.columns = columns;
            this.rows = rows;
            this.mappedCount = mappedCount;
            this.mapped = mapped;
            this.mapIdLookup = mapIdLookup;
            this.coverageVersion = coverageVersion;
            this.targetVersion = targetVersion;
        }

        private boolean matches(int gxMin, int gxMax, int gzMin, int gzMax, long coverageVersion, long targetVersion) {
            return this.gxMin == gxMin
                    && this.gxMax == gxMax
                    && this.gzMin == gzMin
                    && this.gzMax == gzMax
                    && this.coverageVersion == coverageVersion
                    && this.targetVersion == targetVersion;
        }

        public int gxMin() {
            return gxMin;
        }

        public int gzMin() {
            return gzMin;
        }

        public int columns() {
            return columns;
        }

        public int rows() {
            return rows;
        }

        public int mappedCount() {
            return mappedCount;
        }

        public int totalCount() {
            return columns * rows;
        }

        public boolean isMappedAt(int worldGX, int worldGZ) {
            int relativeGX = worldGX - gxMin;
            int relativeGZ = worldGZ - gzMin;
            if (relativeGX < 0 || relativeGX >= columns || relativeGZ < 0 || relativeGZ >= rows) {
                return false;
            }
            int index = relativeGZ * columns + relativeGX;
            return mapped[index];
        }

        public Integer getMapIdAt(int worldGX, int worldGZ) {
            int relativeGX = worldGX - gxMin;
            int relativeGZ = worldGZ - gzMin;
            if (relativeGX < 0 || relativeGX >= columns || relativeGZ < 0 || relativeGZ >= rows) {
                return null;
            }
            int index = relativeGZ * columns + relativeGX;
            int mapId = mapIdLookup[index];
            return mapId != -1 ? mapId : null;
        }
    }
}
